package consolidation

import (
	"context"
	"fmt"
	"time"

	"github.com/thrasher-corp/gct-ta/indicators"
	"github.com/thrasher-corp/gocryptotrader/common"
	gctmath "github.com/thrasher-corp/gocryptotrader/common/math"
	"github.com/thrasher-corp/gocryptotrader/currency"
	"github.com/thrasher-corp/gocryptotrader/exchanges/asset"
	"github.com/thrasher-corp/gocryptotrader/exchanges/kline"
	strategy "github.com/thrasher-corp/gocryptotrader/exchanges/strategy/common"
)

// OnSignal processing signals that have been generated by the strategy.
func (s *Strategy) OnSignal(ctx context.Context, sig interface{}) (_continue bool, err error) {
	if s == nil {
		return false, strategy.ErrIsNil
	}

	if sig == nil {
		return false, strategy.ErrNilSignal
	}

	if s.Config == nil {
		return false, strategy.ErrConfigIsNil
	}

	tn, ok := sig.(time.Time)
	if !ok {
		return false, fmt.Errorf("%w of type: %T", strategy.ErrUnhandledSignal, sig)
	}

	if tn.IsZero() {
		return false, errTimeNotSet
	}

	if tn.Location() != time.UTC {
		return false, errSignalRequiresUTCAlignment
	}

	end := tn.Truncate(s.Config.Interval.Duration())
	if !end.Equal(tn) {
		return false, errIntervalMisalignment
	}

	if s.TimeSeries.Candles == nil {
		fmt.Println("initial deployment")
		start := end.Add(-s.Config.Interval.Duration() * time.Duration(s.Config.Lookback))
		s.TimeSeries, err = s.Config.Exchange.GetHistoricCandles(ctx, s.Config.Pair, s.Config.Asset, start, end, s.Config.Interval)
		if err != nil {
			return false, err
		}
		if len(s.TimeSeries.Candles) > s.Config.Lookback {
			fmt.Println("Inclusive end date for historical data:", len(s.TimeSeries.Candles))
			s.TimeSeries.Candles = s.TimeSeries.Candles[len(s.TimeSeries.Candles)-s.Config.Lookback:]
		}
	} else {
		fmt.Println("tick deployment")
		start := s.TimeSeries.Candles[len(s.TimeSeries.Candles)-1].Time.Add(s.Config.Interval.Duration()).UTC()
		var newCandles kline.Item
		newCandles, err = s.Config.Exchange.GetHistoricCandles(ctx, s.Config.Pair, s.Config.Asset, start, end, s.Config.Interval)
		if err != nil {
			return false, err
		}

		fmt.Println(newCandles.Candles)
		if len(newCandles.Candles) > 1 {
			s.TimeSeries.Candles = append(s.TimeSeries.Candles, newCandles.Candles[:1]...)
		} else {
			s.TimeSeries.Candles = append(s.TimeSeries.Candles, newCandles.Candles...)
		}
		// restrict to lookback?
	}

	bol, err := s.TimeSeries.GetBollingerBands(10, 1.5, 1.5, indicators.Sma)
	if err != nil {
		return false, err
	}

	lowerBand := bol.Lower[len(bol.Lower)-1]
	upperBand := bol.Upper[len(bol.Upper)-1]

	fmt.Println("upper", upperBand)
	fmt.Println("lower", lowerBand)

	latestClose := s.TimeSeries.Candles[len(s.TimeSeries.Candles)-1].Close

	fmt.Println("last close", latestClose)

	switch {
	case s.Open != nil:
		if s.Open.IsLong {
			gain := gctmath.CalculatePercentageGainOrLoss(latestClose, s.Open.EntryPrice)
			fmt.Println("POSITION LONG OPEN CURRENT PNL:", gain)
			if gain >= 0 {
				if gain >= s.Config.RequiredReturn {
					fmt.Println("closing position in profit")
					s.Open.ExitPrice = latestClose
					s.Open.PNL = gain
					s.Open.ExitTime = time.Now()
					s.Closed = append(s.Closed, *s.Open)
					s.Open = nil
				}
			} else {
				if gain <= s.Config.MaxLoss {
					fmt.Println("closing position at a loss")
					s.Open.ExitPrice = latestClose
					s.Open.PNL = gain
					s.Open.ExitTime = time.Now()
					s.Closed = append(s.Closed, *s.Open)
					s.Open = nil
				}
			}
		} else {
			gain := gctmath.CalculatePercentageGainOrLoss(s.Open.EntryPrice, latestClose)
			fmt.Println("POSITION SHORT OPEN CURRENT PNL:", gain)
			if gain >= 0 {
				if gain >= s.Config.RequiredReturn {
					fmt.Println("closing position in profit")
					s.Open.ExitPrice = latestClose
					s.Open.PNL = gain
					s.Open.ExitTime = time.Now()
					s.Closed = append(s.Closed, *s.Open)
					s.Open = nil
				}
			} else {
				if gain <= s.Config.MaxLoss {
					fmt.Println("closing position at a loss")
					s.Open.ExitPrice = latestClose
					s.Open.PNL = gain
					s.Open.ExitTime = time.Now()
					s.Closed = append(s.Closed, *s.Open)
					s.Open = nil
				}
			}
		}
	case latestClose > lowerBand && latestClose < upperBand:
		fmt.Println("Price is consolidating, no action taken")
		s.ConsolidationPeriod++
	case s.ConsolidationPeriod > 0:
		s.ConsolidationTracking = append(s.ConsolidationTracking, s.ConsolidationPeriod)
		s.ConsolidationPeriod = 0

		returns := GetReturnsFromKlineData(s.TimeSeries, 20)
		volatility := volatility(returns)

		size := positionSizeAllocator(s.Config.Funds, portfolioRisk, s.Config.RequiredReturn, volatility)

		var longShort string
		var isLong bool
		if latestClose <= lowerBand {
			// Short this thang
			longShort = "shorting that skirt"
		} else {
			// Long this thang
			longShort = "longing that thong"
			isLong = true
		}

		s.Open = &Position{
			EntryPrice: latestClose,
			Quantity:   size,
			EntryTime:  time.Now(),
			IsLong:     isLong,
		}

		fmt.Printf("%s with amount:%v %s total funds:%v current volatility:%v RISK: %v ExpectedReturn:%v\n",
			longShort,
			size,
			s.Config.Pair,
			s.Config.Funds,
			volatility,
			portfolioRisk,
			s.Config.RequiredReturn)
	default:
		fmt.Println("Price is above or below bands, waiting for consolidation period")
	}
	fmt.Println()
	return false, nil
}

// GetDescription returns the strategy description
func (s *Strategy) GetDescription() strategy.Descriptor {
	if s == nil {
		return nil
	}

	sched := s.Scheduler.GetSchedule()
	untilStart := "immediately"
	if until := time.Until(sched.Next); until > 0 {
		untilStart = until.String()
	}

	sinceStart := "not yet started"
	if since := time.Since(sched.Start); since > 0 {
		sinceStart = since.String()
	}

	return &Description{
		Exchange:           s.Config.Exchange.GetName(),
		Pair:               s.Config.Pair,
		Asset:              s.Config.Asset,
		Start:              sched.Start.UTC().Format(common.SimpleTimeFormat),
		End:                sched.End.UTC().Format(common.SimpleTimeFormat),
		UntilStart:         untilStart,
		SinceStart:         sinceStart,
		DeploymentInterval: s.Config.Interval,
		OperatingWindow:    sched.Window.String(),
		Simulation:         s.Config.Simulate,
	}
}

// Description defines the full operating description of the strategy with its
// configuration parameters.
type Description struct {
	Exchange           string         `json:"exchange"`
	Pair               currency.Pair  `json:"pair"`
	Asset              asset.Item     `json:"asset"`
	Start              string         `json:"start"`
	End                string         `json:"end"`
	UntilStart         string         `json:"untilStart"`
	SinceStart         string         `json:"sinceStart"`
	Aligned            bool           `json:"aligned"`
	DeploymentInterval kline.Interval `json:"deploymentInterval"`
	OperatingWindow    string         `json:"operatingWindow"`
	Overtrade          bool           `json:"overtrade"`
	Simulation         bool           `json:"simulation"`
}

// String implements stringer interface for a short description
func (d *Description) String() string {
	if d == nil {
		return ""
	}

	sim := "[STRATEGY IS LIVE]"
	if d.Simulation {
		sim = "[STRATEGY IS IN SIMULATION]"
	}

	return sim
}
