package twap

import (
	"context"
	"errors"
	"fmt"
	"time"

	"github.com/thrasher-corp/gocryptotrader/common"
	strategy "github.com/thrasher-corp/gocryptotrader/exchanges/strategy/common"
)

const twapTag = "TWAP"

// Run inititates a TWAP allocation using the specified paramaters.
func (s *Strategy) Run(ctx context.Context) error {
	if s == nil {
		return strategy.ErrIsNil
	}

	s.mtx.Lock()
	defer s.mtx.Unlock()

	if s.running {
		return strategy.ErrAlreadyRunning
	}

	if s.Config == nil {
		return strategy.ErrConfigIsNil
	}

	var start time.Duration
	if s.CandleStickAligned {
		// If aligned this will need to be truncated
		var err error
		start, err = s.GetNextSchedule(s.Start)
		if err != nil {
			return err
		}
	}
	s.shutdown = make(chan struct{})
	s.wg.Add(1)
	go s.deploy(ctx, start)
	s.running = true
	return nil
}

// Stop stops the twap strategy.
func (s *Strategy) Stop() error {
	if s == nil {
		return strategy.ErrIsNil
	}

	s.mtx.Lock()
	defer s.mtx.Unlock()

	if !s.running {
		return strategy.ErrNotRunning
	}

	close(s.shutdown)
	s.wg.Wait()
	s.running = false
	return nil
}

// IsRunning checks to see if the strategy is running
func (s *Strategy) GetReporter() (strategy.Reporter, error) {
	if s == nil {
		return nil, strategy.ErrIsNil
	}

	s.mtx.Lock()
	defer s.mtx.Unlock()
	if s.reporter == nil {
		s.reporter = make(strategy.Reporter, 1)
	}
	return s.reporter, nil
}

// GetState returns the state of the strategy
func (s *Strategy) GetState() (*strategy.State, error) {
	if s == nil {
		return nil, strategy.ErrIsNil
	}

	s.mtx.Lock()
	defer s.mtx.Unlock()

	return &strategy.State{
		Exchange: s.Config.Exchange.GetName(),
		Pair:     s.Config.Pair,
		Asset:    s.Config.Asset,
		Strategy: twapTag,
		Running:  s.running,
	}, nil
}

// OnSignal processing signals that have been generated by the strategy.
func (s *Strategy) OnSignal(ctx context.Context, sig interface{}) (bool, error) {
	if s == nil {
		return false, strategy.ErrIsNil
	}

	if sig == nil {
		return false, errors.New("signal is non-existant")
	}

	if _, ok := sig.(time.Time); !ok {
		return false, errors.New("unhandled signal")
	}

	err := s.checkAndSubmit(ctx)
	if err != nil {
		return false, err
	}

	if s.allocation.Deployed == s.allocation.Total {
		return true, nil
	}

	return false, nil
}

// String implements stringer interface.
func (s *Strategy) String() string {
	if s == nil {
		return ""
	}

	return fmt.Sprintf("Strategy:%s Start:%s End:%s Exchange:%s Pair:%s Asset:%s Interval:%s Window:%s Simulation:%v Amount:%f Deployent:%f",
		"TWAP",
		s.Start.Format(common.SimpleTimeFormat),
		s.End.Format(common.SimpleTimeFormat),
		s.Config.Exchange.GetName(),
		s.Config.Pair,
		s.Config.Asset,
		s.Config.Interval,
		s.allocation.Window,
		s.Config.Simulate,
		s.allocation.Total,
		s.allocation.Deployment)
}
